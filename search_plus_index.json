{"./":{"url":"./","title":"Introduction","keywords":"","body":"emberjs-guide 非官方中文实践指南 本文档是 wecatch 在实际业务中引入和实践 emberjs【基于 LTS 版本 3.28 】的经验之作，其中的教程部分来自官方站点 https://guides.emberjs.com/v3.28.0。 © 三月沙 all right reserved，powered by GitbookUpdated at 2022-02-27 14:50:58 "},"book/why-emberjs.html":{"url":"book/why-emberjs.html","title":"为什么是 emberjs","keywords":"","body":"为什么是emberjs emberjs 被 wecatch 选中用于比较复杂的资源管理项目中，比如公司内部的CMS，各种 dashboard 等， 此类项目基本具有如下特点： 表单多，频繁与后端进行交互 数据形式复杂，表现形式相对单一，比如大量的 table、card、grid等组织形式 交互复杂，交互尽量在单页完成 在小团队中，尤其是创业公司，此类 CMS 系统往往缺乏明晰的前后端职责划分，前后端常由相同的人员担当，加上人员流动，需求频繁变更导致可维护性，可持续性差，因而必须要有非常严格的规范来保证代码的一致性和体验的一致性。 Convention over configuration is an important philosphy in Ember. 约定优于配置，这是 emberjs 的重要理念，正是这种理念，ember 应用才具有非常一致的代码组织结构和代码风格，为应用的可维护性提供了最基本的保证，而可复用的组件又为应用提供了一致和可持续的交互体验。 能胜任复杂庞大的单页应用 具有强制规范，具有可复用的组件 支持双向绑定以处理频繁的表单操作 有完备的构建流程和构建工具(ember-cli) 有成熟的案例builtwithember 有活跃的社区discuss 类似于传统 MVC 的模板表达语言handlebars 有丰富的库 https://emberobserver.com/ 方便不了解前端的后端同学来实现 html 的逻辑 这些优势让 wecatch 选择了 emberjs © 三月沙 all right reserved，powered by GitbookUpdated at 2022-01-22 10:25:17 "},"book/":{"url":"book/","title":"introduction","keywords":"","body":"介绍 Emberjs 是一个 JavaScript 框架，可以用来构建非常复杂的 web 应用，emberjs 的设计理念是约定大于配置，本身具有固定的开发模式以及完备的开发工具，一旦掌握，生产效率将成倍提升。 基础概念和架构 图片出自:5-essential-ember-2.0-concepts 上图描述了 emberjs 中架构和基本概念： router route model controller service component Router Router 负责组织 route，并处理 route 之间的层级关系，是 route 的 manager。 Route Route 就是 web 的路由，优秀的 web 应用总是从良好的路由设计开始的。 Model Emebr 中的数据对象，可以是任意的 JavaScript 对象、数组或 promise，ember 提供了 ember-data 来处理所有与数据相关的事情。 Service service 是一个单实例 ember 对象，在 emebr 应用中负责全局性的事务处理，比如登录会话信息等。 Component 类似 react 和 vuejs 中的 component，完整的包含了渲染 UI 所需要的状态、HTML以及事件交互。 Template & Controller Controller 连接 route 和 template，在对应的 template 中渲染 route 中的 model 数据。 © 三月沙 all right reserved，powered by GitbookUpdated at 2022-02-27 14:04:12 "},"book/create-app.html":{"url":"book/create-app.html","title":"构建第一个 ember 应用程序","keywords":"","body":"构建 ember 应用程序 构建 ember app 使用官方出品的构建工具 ember-cli npm install -g ember-cli@3.28 安装完成之后，创建一个空文件夹 my-app，然后进入执行初始化 mkdir my-app cd my-app ember init 等待安装完成，然后启动 server ember serve Build successful (13454ms) – Serving on http://localhost:4200/ Slowest Nodes (totalTime >= 5%) | Total (avg) ------------------------------------------------------------------------------------------+----------------------- Babel: ember-source (5) | 4586ms (917 ms) Babel: @ember/test-helpers (1) | 2162ms BroccoliRollup (6) | 988ms (164 ms) Bundler (1) | 881ms 打开浏览器访问 http://localhost:4200/ © 三月沙 all right reserved，powered by GitbookUpdated at 2022-01-22 10:25:17 "},"book/app-dir-structure.html":{"url":"book/app-dir-structure.html","title":"ember app 目录结构介绍","keywords":"","body":"ember app 目录结构介绍 ├── README.md ├── app │ ├── adapters │ ├── app.js │ ├── components │ ├── controllers │ ├── helpers │ ├── index.html │ ├── models │ ├── router.js │ ├── routes │ ├── serializers │ ├── styles │ └── templates ├── config │ ├── ember-cli-update.json │ ├── environment.js │ ├── optional-features.json │ └── targets.js ├── dist │ ├── api │ ├── assets │ ├── ember-welcome-page │ ├── index.html │ ├── robots.txt │ ├── testem.js │ └── tests ├── ember-cli-build.js ├── package-lock.json ├── package.json ├── public │ ├── api │ ├── assets │ └── robots.txt ├── testem.js tests ├── acceptance │ └── super-rentals-test.js ├── helpers ├── index.html ├── integration │ └── components ├── test-helper.js └── unit ├── adapters // ember-data adapter ├── models // model ├── routes // route └── serializers // ember-data serializer └── vendor 秉承约定优于配置的设计理念，ember app 的目录结构，文件命名，变量名由官方做了统一规范，每个文件名称以及目录都可以用 ember-cli 命令来生成: ember generate --help 因此开发者无需考虑包目录结构，随着项目复杂性变高，文件变多，也无需为制定各种命名规范以及划分各种包的层级一级结构而付出额外的成本，专心于业务功能的开发即可，省心省力。 © 三月沙 all right reserved，powered by GitbookUpdated at 2022-01-22 10:25:17 "},"book/component/":{"url":"book/component/","title":"认识 Component","keywords":"","body":"认识 Component Component 是 emberjs 中的重要概念，emberjs 的 Component 和 vuejs 以及 reactjs 等 ui-component 概念大同小异，并无本质差别，都是具有独立逻辑且可复用的 UI 单元。 定义 Component 在 ember 使用 ember generate 命令可以快速定义一种类型，简写为 ember g，生成一个组件如下： % ember g component hello installing component create app/components/hello.hbs skip app/components/hello.js tip to add a class, run `ember generate component-class hello` installing component-test create tests/integration/components/hello-test.js % ember g component world installing component create app/components/world.hbs skip app/components/world.js tip to add a class, run `ember generate component-class world` installing component-test create tests/integration/components/world-test.js 上面的命令会生成两个 hbs 文件： % tree app/components app/components ├── hello.hbs └── world.hbs 文件的内容是： {{yield}} 我们将其中的内容分别改为： hello.hbs Hello world.hbs world 使用 Component 打开编辑器，在 application.hbs 中使用上面的组件 Emberjs 可以看到组件的使用就如同普通的 html tag 一样，ember 约定 ember 定义的组件是以 <> 的形式使用，支持 self closing 形式 ，组件名称风格是 Pascal 命名法，但是组件的文件名称中如果包含多个单词，则采用连字符 -比如，组件 对应的文件名称是： app/components ├── hello-world.hbs © 三月沙 all right reserved，powered by GitbookUpdated at 2022-02-27 14:08:10 "},"book/component/template-is-html.html":{"url":"book/component/template-is-html.html","title":"认识 Template","keywords":"","body":"认识 template ember 的 template 本质就是 html，也就意味着合法的 html 内容都会被支持，但是也有限制，比如不能在 template 中使用 ，不能使用不合法的 html tag，除此之外其他合法的 html 内容都可以使用比如： Web component SVG HTML comments White space ... 复制以下 html 内容到 app/templates/application.hbs: T Tomster their local time is 4:56pm Hey Zoey, have you had a chance to look at the EmberConf brainstorming doc I sent you? Z Zoey Hey! I love the ideas! I'm really excited about where this year's EmberConf is going, I'm sure it's going to be the best one yet. Some quick notes: Definitely agree that we should double the coffee budget this year (it really is impressive how much we go through!) A blimp would definitely make the venue very easy to find, but I think it might be a bit out of our budget. Maybe we could rent some spotlights instead? We absolutely will need more hamster wheels, last year's line was way too long. Will get on that now before rental season hits its peak. Let me know when you've nailed down the dates! Message Send 复制以下 css 到 app/styles/app.css ，ember 的 style 文件在 app/styles 目录中，此外 ember 也支持使用 less、sass 等扩展语言，安装对应的 ember addon 即可。 body { max-width: 800px; margin: auto; padding: 2em; font-family: sans-serif; background-color: #fdfdfd; } .messages { display: grid; grid-template-columns: 80px 1fr; padding: 2em; border-radius: 0.5em; box-shadow: 0 0.25em 1.5em 0.25em rgba(0, 0, 0, 0.1); } .messages > section { margin-bottom: 1.5em; line-height: 1.5em; } .messages p, .messages ul, .username { margin: 0.5em 0; } .local-time { font-size: 0.8em; color: #da6c4d; font-weight: normal; margin-left: 10px; } .avatar { position: relative; border-radius: 50%; width: 60px; height: 60px; text-align: center; line-height: 60px; color: white; font-weight: bold; background-color: #ff907b; } .avatar.is-active:after { content: \" \"; height: 14px; width: 14px; border: solid 3px white; border-radius: 50%; background-color: #8bc34a; position: absolute; bottom: 0; right: 0; } .current-user .avatar { background-color: #30aba5; } form { display: grid; grid-column: span 2; grid-template-columns: 1fr 6em; } form > input { padding: 0.5em; border-top-left-radius: 0.5em; border-bottom-left-radius: 0.5em; border: 1px solid #cccccc; border-right: none; font-size: 1em; } form > button { border-top-right-radius: 0.5em; border-bottom-right-radius: 0.5em; border: 1px solid #cccccc; font-size: 1em; } 浏览器会自动刷新，内容如下 © 三月沙 all right reserved，powered by GitbookUpdated at 2022-01-22 10:25:17 "},"book/component/introduce-component.html":{"url":"book/component/introduce-component.html","title":"引入 Component 重构 HTML","keywords":"","body":"引入 Component 重构 HTML 上文中 html 内容全部在 application.hbs 中，这种实现方式显然不够优雅，代码的可复用性、可维护性都不好，可以利用 component 的复用能力，把 html 内容进行封装的独立使用，因此我们第一步就是要对 html 内容进行拆解，形成可复用的单元 经过拆解我们的 UI 部分可以由以下几部分组成 因此我们生成三个组件 ember g component received-message ember g component sent-message ember g component input-message app/components/received-message.hbs T Tomster their local time is 4:56pm Hey Zoey, have you had a chance to look at the EmberConf brainstorming doc I sent you? app/components/sent-message.hbs Z Zoey Hey! I love the ideas! I'm really excited about where this year's EmberConf is going, I'm sure it's going to be the best one yet. Some quick notes: Definitely agree that we should double the coffee budget this year (it really is impressive how much we go through!) A blimp would definitely make the venue very easy to find, but I think it might be a bit out of our budget. Maybe we could rent some spotlights instead? We absolutely will need more hamster wheels, last year's line was way too long. Will get on that now before rental season hits its peak. Let me know when you've nailed down the dates! app/components/input-message.hbs Message Send 在 application.hbs 中使用组件 嵌套组件 为了让 UI 达到更好的复用，我们可以继续对上文中的组件进行拆分，形成更细粒度的组件，比如我们可以拆分出 SendMessage 的 UserName 以及 ReceivedMessage 的 UserName ember g component received-message/user-name ember g component sent-message/user-name 在 ember 中像 user-name 这种嵌套定义在父组件目录下的组件称之为嵌套组件，调用时父组件后跟::然后再跟组件名称 同理也可以对 avatar 部分的 html 进行相同拆分 ember g component received-message/avatar ember g component sent-message/avatar ember 支持多层嵌套，而且 ember 支持为组件定义一个index.hbs 且在使用的时候不需要添加 ::Index ，因而 app/components/received-message.hbs 可以替换为 app/components/received-message/index.hbs mv app/components/received-message.hbs app/components/received-message/index.hbs mv app/components/sent-message.hbs app/components/sent-message/index.hbs app/ components/ -received-message.hbs received-message/ +index.hbs avatar.hbs username.hbs 使用保持方式不变 © 三月沙 all right reserved，powered by GitbookUpdated at 2022-02-26 12:02:31 "},"book/component/component-arguments-html-attributes.html":{"url":"book/component/component-arguments-html-attributes.html","title":"Component 的参数和 HTML 属性 ","keywords":"","body":"Component 的参数和 html 属性 Component 的最重要的作用就是让 UI 单元具有复用的作用，上文中我们通过把 HTML 进行拆分和封装形成了独立可以复用的单元，但是这些组件都只是一个普通的静态 UI，不包含任何的交互和数据，观察 avatar 这两个组件： app/components/received-message/avatar.hbs T app/components/sent-message/avatar.hbs Z 他们的区别可能只在于 class 名称以及 title 名称的差异，component 支持传入参数来实现根据参数不同展示不同的 UI。 app/components/avatar.hbs {{@initial}} ember 通过 @ 来实现在 template 中获取传入 component 的 argument，在 ember 中 : {{}} 表示要执行一个表达式，如果不用双 {} ，变量会被当成字符串渲染。 使用这个新的 avatar 组件： app/components/received-message/avatar.hbs app/components/sent-message/avatar.hbs HTML 属性 上文中新的 Avatar 组件并没有 class，component 除了通过 @ 传入组件属性以外，还支持传入任意 html 属性 app/components/received-message/avatar.hbs app/components/avatar.hbs {{@initial}} ...attributes 会把任意的 component 的 html 属性渲染出来，如果希望用户可以覆盖组件自身的 attribute ，就把 ...attributes 放在想要覆盖的 attribute 后面，因此 ...attributes 的位置会影响最终属性的渲染。 © 三月沙 all right reserved，powered by GitbookUpdated at 2022-02-27 14:22:40 "},"book/component/component-state-and-action.html":{"url":"book/component/component-state-and-action.html","title":"Component 的状态和事件","keywords":"","body":"Component 的状态和交互 Component 的 template 决定 UI 的静态模型，Component 的 JavaScript 可以为 UI 提供交互式操作(Event)和数据(State)，联结二者的是 action：可以在 template 中使用的 JavaScript 方法， 形如： +1 Component 的状态 状态就是 component 的属性，这些属性会随着 component 的变化而变化，有些属性会以 UI 的形式呈现给用户，也就是当属性发生变化时，UI 会及时变化反馈出阿里，这种通过跟踪属性状态改变 UI 的能力在 ember 中叫 autotrack ，实现 autotrack 能力的属性叫 tracked propertiy。 app/components/counter.js import Component from '@glimmer/component'; import { tracked } from '@glimmer/tracking'; export default class CounterComponent extends Component { @tracked count = 0; } 上述例子中的 count 中具有了 autotrack 的能力，当 autotrack 值发生改变时，对应 template 中的值也会发生变化，比如 count 的值发生改变时，template 中的值也会发生改变： app/components/counter.hbs {{this.count}} +1 -1 Ember 通过 this 来区分属性是来自 component argument 还是 component 自身，属于 component 自身的属性通过 this 来获取。 改变 Component 的状态 State 提供了 component 静态的数据，action 提供了改变 state 的能力，想要在 template 中使用 action，就需要借助 HTML modifier： app/components/counter.hbs {{this.count}} +1 -1 on 是 ember 内建的一个 mofidier，用来把 event 绑定到 HTML tag。 app/components/counter.js import Component from '@glimmer/component'; import { tracked } from '@glimmer/tracking'; import { action } from '@ember/object'; export default class CounterComponent extends Component { @tracked count = 0; @action increment() { this.count = this.count + 1; } @action decrement() { this.count = this.count - 1; } } 而 action 就是很普通的用 action 装饰的 JavaScript 方法。 为 action 提供参数 有时候直接使用 action 并不能满足需要，还需要为 action 提供参数来实现更复杂的交互能力，ember 使用 fn modifier 来实现对 action 传递参数： app/components/counter.js import Component from '@glimmer/component'; import { tracked } from '@glimmer/tracking'; import { action } from '@ember/object'; export default class CounterComponent extends Component { @tracked count = 0; @action change(amount) { this.count = this.count + amount; } } app/components/counter.hbs {{this.count}} +1 -1 fn 的含义就是把参数和 action 重新再包装成一个函数来使用。 计算属性 Computed value 是 ember 提供的一种以声明式编程的方式动态计算属性的能力，通过这种能力，如果某个 state 的改变要依赖其他 state，只要被依赖的 state 具有 autotrack 能力，那么该 state 也会在被依赖的 state 发生变化时而改变，下面的例子中，total 这个属性依赖 count 和 multiple，通过 get 来实现根据 count 和 multiple 的依赖计算 total app/components/counter.js import Component from '@glimmer/component'; import { tracked } from '@glimmer/tracking'; import { action } from '@ember/object'; export default class CounterComponent extends Component { @tracked count = 0; @tracked multiple = 1; @action double() { this.multiple = this.multiple * 2; } get total() { return this.count * this.multiple; } @action change(amount) { this.count = this.count + amount; } } app/components/counter.hbs {{this.count}} {{this.total}} +1 -1 double 在 JavaScript 中使用 component arguments 在前文中，我们讲过在 template 中通过 @ 来获取 component arguments，同理 JavaScript 中也提供了通过 this.args 来获取 argument 的能力，这就意味着 component 之间有了相互沟通的能力。 app/components/double-it.js import Component from '@glimmer/component'; import { tracked } from '@glimmer/tracking'; import { action } from '@ember/object'; export default class DoubleItComponent extends Component { @tracked multiple = 1; @action updateMultiple(newMultiple) { this.multiple = newMultiple; } } app/components/double-it.hbs app/components/counter.js import Component from '@glimmer/component'; import { tracked } from '@glimmer/tracking'; import { action } from '@ember/object'; export default class CounterComponent extends Component { @tracked count = 0; get total() { return this.count * this.args.multiple; } @action change(amount) { this.count = this.count + amount; } @action double() { this.args.updateMultiple(this.args.multiple * 2); } } ` © 三月沙 all right reserved，powered by GitbookUpdated at 2022-02-27 14:28:29 "},"book/component/component-condition-and-loop.html":{"url":"book/component/component-condition-and-loop.html","title":"Component 实现逻辑判断和循环","keywords":"","body":"Component 实现逻辑判断和循环 在 template 中，可以使用 if 进行条件判断，ember 提供的条件判断包括两种形式：block（块状） 和 inline（内联）： {{#if this.thingIsTrue}} Content for the block form of \"if\" {{/if}} This div used the inline \"if\" to calculate the class to use. Block if Block 条件判断正如字面意思提供的是基于块状的逻辑判断，类似 HTML 中的 block 元素: {{#if condition}} {{!-- some content --}} {{/if}} 并且 block condition 支持 else: {{#if condition}} {{!-- some content --}} {{else}} {{!-- some other content --}} {{/if}} {{#if condition1}} ... {{else if condition2}} ... {{else if condition3}} ... {{else}} ... {{/if}} Inline if Inline 条件判断可以在一个表达式中完成逻辑判断: {{if condition value}} 同样 inline 也支持 else: {{if condition value1 value2}} Inline 的方式经常用于对 HTML class 的判断中，比如根据用户是否登陆而赋予不同的 class: {{@initial}} Template 中的循环 循环使用 each 完成，each 和 if 一样，在 ember 中都称之为 helper，是 ember 支持的在 template 中实现 JavaScript 逻辑的一种能力 ： {{#each this.messages as |message|}} {{{message.content}}} {{/each}} 如果循环对象 this.messages 发生了变更，template 会自动进行渲染，each 还支持 index 以及 else {{#each this.queue as |person index|}} Hello, {{person.name}}! You're number {{index}} in line {{/each}} {{#each this.queue as |person index|}} Hello, {{person.name}}! You're number {{index}} in line {{else}} Empty list {{/each}} 类似 javascript 中的 for..in 语句，each-in 提供对 object 进行迭代的能力： const categories = { 'Bourbons': ['Bulleit', 'Four Roses', 'Woodford Reserve'], 'Ryes': ['WhistlePig', 'High West']} {{#each-in this.categories as |category products|}} {{category}} {{#each products as |product|}} {{product}} {{/each}} {{/each-in}} © 三月沙 all right reserved，powered by GitbookUpdated at 2022-02-27 14:35:12 "},"book/component/custome-component.html":{"url":"book/component/custome-component.html","title":"更灵活的控制 Component 的渲染：Block content","keywords":"","body":"更灵活的控制 Component 的渲染：Block content 如果想自定义 component 的模板，可以使用 block form，即在模板中使用 {{yield}} 表达式, yield 的含义是在 tempalte 中提供一个 placeholder 让用户可以自定义 template 的内容： app/components/message.hbs {{yield}} app/components/received-message.hbs Hey Zoey, have you had a chance to look at the EmberConf brainstorming doc I sent you? 其中received-message.hbs 部分: Hey Zoey, have you had a chance to look at the EmberConf brainstorming doc I sent you? 将会替代 message.hbs yield 出现的地方，这个例子中 message 提供了用户自定义 message 内容主体的能力。 条件 Block content has-block 可以用来判断 component 是否有 block： {{#if (has-block)}} {{yield}} {{else}} An unknown error occurred! {{/if}} 如果有自定义内容就显示内容，否则显示默认的内容。 把 component 传递到组件外部 yield 除了可以作为占位符之外，还提供把 template 的内容主动传递到 component 外部使用的能力： {{@post.title}} {{@post.author}} {{yield @post.body}} {{postBody}} 传递多个参数： {{yield @post.title @post.author @post.body }} {{postTitle}} {{postBody}} 如果在某些场合 component 不需要 yield，可以使用 hasBlock 判断当前组件的使用是否是以 block form 的使用 app/templates/components/blog-post.hbs {{#if hasBlock}} {{yield post.title}} {{yield post.body}} {{yield post.author}} {{else}} {{post.title}} Authored by {{post.author}} {{post.body}} {{/if}} © 三月沙 all right reserved，powered by GitbookUpdated at 2022-02-27 14:39:14 "},"book/component/component-life-circle.html":{"url":"book/component/component-life-circle.html","title":"Component 的生命周期","keywords":"","body":"Component 的生命周期 基础概念 attrs ，通过外部传递给 component 称之为 attrs property，内部的属性称之为 property 导致 component 重新渲染的条件 any of its attributes change component.set() is called component.rerender() is called a property on a model or service used by the template has changed (including through computed properties). 注意：任何外部 attribute 或者内部的 property 发生了改变，包括 model 中的属性、service 中的属性，且这些 property 在 component 的模板中被使用，都会触发 component 重新渲染 Component 第一次初始化要历经： init-->didReceiveAttrs-->willRender-->didInsertElement-->didRender 当组件渲染完毕，之后属性发生改变再次渲染时又会历经: didUpdateAttrs-->didReceiveAttrs-->willUpdate-->willRender-->didUpdate-->didRender 组件生命周期结束之后被销毁会历经 willDestroyElement-->willClearRender-->didDestroyElement 每个生命周期的 hooks 都有相应的职能，所以调用它们要选在恰当的时候。 init 初始化组件，在此 hooks 可以完成对相应属性的最基本的声明和初始化工作 使用 didUpdateAttrs 重置组件的展示状态 didUpdateAttrs runs when the attributes of a component have changed, but not when the component is re-rendered, via component.rerender, component.set, or changes in models or services used by the template. didUpdateAttrs 在 attrs 发生改变之后执行，并且在 re-render 之前执行，但是 Component 通过 component.rerender, component.set, or changes in models or services 发生改变 时不会触发 didUpdateAttrs。 可以把此 hooks 当成很好的 observer 来执行相应的处理逻辑。需要注意：didUpdateAttrs 执行是指 component 从外部传递的属性发生改变，而不是 Component 内部属性发生改变，比如通过 set 改变 Component 某个属性。 {{#each errors as |error|}} {{error.message}} {{/each}} {{input name=\"user.name\" value=name change=(action \"required\")}} {{input name=\"user.department\" value=department change=(action \"required\")}} {{input name=\"user.email\" value=email change=(action \"required\")}} import { A } from '@ember/array'; import Component from '@ember/component'; export default Component.extend({ init() { this._super(...arguments); this.set('errors', A([])); }, didUpdateAttrs() { this._super(...arguments); this.set('errors', A([])); }, actions: { required(event) { if (!event.target.value) { this.errors.pushObject({ message: `${event.target.name} is required`}); } } } }); 使用 didReceiveAttrs 格式化 component Attributes didReceiveAttrs runs after init, and it also runs on subsequent re-renders, which is useful for logic that is the same on all renders. It does not run when the re-render has been initiated internally. didReceiveAttrs 在 init 之后执行，也会在 re-render 时在 didUpdateAttrs 之后执行，因此这个 hooks 可以用在初次渲染和再次渲染时处理相同的业务逻辑，同 didUpdateAttrs 一样，可以当成一个 observer。如果 re-render 是由 Component 内部触发引起的，此 hooks 并不会执行，比如更改了 component 一个 property。 比如下面的例子根据传入的 data 格式来格式化数据 import Component from '@ember/component'; export default Component.extend({ didReceiveAttrs() { this._super(...arguments); const profile = this.data; if (typeof profile === 'string') { this.set('profile', JSON.parse(profile)); } else { this.set('profile', profile); } } }); 使用 didInsertElement 集成第三方组件 After a component successfully renders its backing HTML element into the DOM, it will trigger its didInsertElement() hook. 一个 Component 的所有 dom 都渲染完毕之后会执行此 hook，这个时候就可以在此执行和调用第三方库进行 dom 的修改或事件的绑定，但是请谨记，这个 hook 只在初次渲染时调用。 The component's element has been both created and inserted into the DOM. The component's element is accessible via the component's this.element this.element 返回的是纯 dom，如果需要 jQuery，可以 import jquery from \"@ember/jquery\", 然后使用 $(this.elment) import Component from '@ember/component'; export default Component.extend({ didInsertElement() { this._super(...arguments); this.element.setAttribute('contenteditable', true); } }); 注意事项： It is only triggered once when the component element is first rendered -- 只在组件第一次渲染执行一次 In cases where you have components nested inside other components, the child component will always receive the didInsertElement() call before its parent does -- 子组件总是比父组件优先调用. Setting properties on the component in didInsertElement() triggers a re-render, and for performance reasons, is not allowed -- 不要在 didInsertElement 中执行更改组件属性的行为. While didInsertElement() is technically an event that can be listened for using on(), it is encouraged to override the default method itself, particularly when order of execution is important -- 可以使用 on 来监听 didInsertElement 方法，为了保证所有的 hook 可以正确按照顺序调用可以考虑覆盖默认方法. didRender The didRender hook is called during both render and re-render after the template has rendered and the DOM updated. You can leverage this hook to perform post-processing on the DOM of a component after its been updated. 当 dom 都准备后了之后，didRender 被执行，可以在 didRender 中执行 dom 完成之后的更新，比如计算 dom 容器的高度等等。 各个 hook 使用注意事项 didUpdateAttrs 和 didReceiveAttrs 是在外部传递给 component 的属性发生改变时导致 re-render 重新执行才会调用，如果是组件内部发生的导致属性改变而re-render，这两个 hooks 都不会执行，有一点需要注意，虽然这两个 hooks 可以当做 oberver 来使用，但对应的属性最好都是 object 才会在属性发生改变时调用 hooks，详见 ember-cli-simditor component 的实现。 component 内部属性发生改变，会导致 willUpdate、willRender、didUpdate、didRender 执行 不要在 {will,did}{Render,Update} 更改 component 的内部或外部属性，这样会导致性能问题或无限的更新循环 © 三月沙 all right reserved，powered by GitbookUpdated at 2022-01-22 10:25:17 "},"book/component/action.html":{"url":"book/component/action.html","title":"Component 的事件处理","keywords":"","body":"component 的事件处理 component 中的事件处理非常简单，只需要在 component 实现对应的事件名称的方法即可，需要注意名称必须符合 camelStyle // app/components/double-clickable.js import Ember from 'ember'; export default Ember.Component.extend({ doubleClick() { Ember.Logger.info(\"DoubleClickableComponent was clicked!\"); return true; } }); doubleClick 是事件名称，对应的事件是 doubleClick，如果在事件方法中 return true，事件将会冒泡到父元素中 响应外部 action 在某些场景中，处理完 component 内部事件之后需要内部产生的数据通过响应外部的 action 发送出去，这在 ember 中也很容易实现 {{drop-target action=(action \"didDrop\")}} //app/components/drop-target.js import Ember from 'ember'; export default Ember.Component.extend({ attributeBindings: ['draggable'], draggable: 'true', dragOver() { return false; }, drop(event) { let id = event.dataTransfer.getData('text/data'); let response = this.get('action')(id); Ember.Logger.info(response); } }); 属性 action 传递的值是 action didDrop，这个属性对应的值在 component 内部其实就相当于一个很普通的函数，可以非常容易在内部调用此函数 this.get('action')(id)，甚至可以拿到调用函数的返回值 let response = this.get('action')(id);。 事件的更多介绍 见 ../action.md © 三月沙 all right reserved，powered by GitbookUpdated at 2022-01-22 10:25:17 "},"book/component/QA.html":{"url":"book/component/QA.html","title":"QA","keywords":"","body":"Component 的两种不同调用方式的区别 Component 支持 {{my-component}} 和 两种调用方式，{{}} 的形式支持位置参数，而 <> 形式默认都是带名字参数，如果在 Component 中声明了： import Component from '@ember/component'; export default Component.extend({ }).reopenClass({ positionalParams: ['greeting', 'name'] }); 则调用的时候也必须显式指定： 还可以直接指定数组的形式： import Component from '@ember/component'; export default Component.extend({ }).reopenClass({ positionalParams: 'params' }); 然后调用的时候告诉 params 是数组： 何时使用传统的形式 {{some-component param1 param2}} {{ui/foo-bar}} 一个是占位参数，一个 Component 是按照文件目录嵌套调用的 © 三月沙 all right reserved，powered by GitbookUpdated at 2022-02-26 11:53:39 "},"book/route/":{"url":"book/route/","title":"路由","keywords":"","body":"Ember app 和传统的 web 应用一样，URL 代表着一切，你可以从 URL 上得知当前用户是在查看一篇文章还是在编辑一篇文章，Ember app 就是通过 url 来管理这一切的。 一般来说，URL 可以以下几种方式改变： 用户第一次加载 app 用户手动更改 URL，比如用户点击回退按钮或编辑地址栏 用户点击 app 内部的链接 其他一些事件导致 URL 发生变化 无论 URL 是如何被改变的，Ember router 都会把当前的 URL 映射到一个或多个 route handler。 介绍 Route 顾名思义就是路由，一个 URL 对应一个 route，一个 route 对应一个 controller 和 template (hbs)，一个 template 可以包括一个或多个 component，而 route 的作用就是： 渲染 template 渲染页面 load model from backend api 加载数据 redirect to a new route 重定向 在 Ember app 中创建一个 route 很简单： ember generate route route-name 这个命令会在 app/routes/route-name.js 生成一个 route，在 app/templates/route-name.hbs 生成一个 template，在 tests/unit/routes/route-name-test.js 生成一个单元测试，在 router 中添加一个 route： Router.map(function() { this.route('route-name', { path: '/route-name' }); }); 注意：如果 route 是由多个单词组成的，使用 - 作为连接符。 嵌套的路由 Ember 的路由通过路由 nest 的方式实现页面的嵌套，比如你想实现在博客列表页创建一篇博客，就可以这样实现： Router.map(function() { this.route('posts', function() { this.route('new'); }); }); 然后再 posts.hbs 中添加： Posts {{outlet}} outlet 这个 helper 就是你想让嵌套路由 new 渲染的地方，也就是说如果用户只是访问 /posts ，Ember 将会渲染 posts.hbs ，如果用户访问 /posts/new ，Ember 会把 posts/new.hbs 渲染在 outlet 出现的位置，也就是 posts.hbs 模板中。 注意：嵌套路由的名称必须要保护父级的名字，也就是在 transitionTo 和 link-to 中要写成 posts.new . 模板渲染的机制 当 url 发生改变会，会进入对应的 route，当 route 获取数据 model 成功之后进行模板渲染，模板中的 component 在当前 route 对应的 hbs 首次初始化时进行实例化，生成 component 对应的实例，component 在某些情况下会重新渲染，这里需要注意的是： 如果当前的 url 未发生改变，也就是当前 url 的 route 未发生改变，则当前的 route 对应的 hbs 不重新进行渲染，而且 hbs 中包含的已实例化的 component 如果不手动触发重新实例化，则这些组件并不会再次进行实例化，这类情况更多的见于 url 参数部分即 segment 部分发生改变，route 不变得情况，比如 url ==> /item/1, url ==> /item/2 对应的 route 是 item, 仅仅只是参数部分变化，比如 id==>1, id==>2，此时 item route 对应的 hbs 并不会重新渲染，包含的组件也只在 hbs 初始化之后初始化一次，之后不在发生变化。 如果直接从浏览器键入 url 访问，则每次进入对应的 route 都会重新渲染对应的 hbs，因为此时 hbs 并没有进行初始化。 入口路由 application application route 是 Ember app 的入口路由，意味着 Ember app 首次加载必定会加载路由对应的模板 application.hbs ，所有其他的路由都会把模板渲染到 application.hbs 中的 outlet 。 由于是默认的入口路由，router 中不需要体现。 Index route Ember 会默认为每个层级的的 route 添加有一个 index route，包括最顶层的 application，index route 对应的 path 就是该层路由的 / ，所以下面的代码： Router.map(function() { this.route('favorites'); }); 其实等价于： Router.map(function() { this.route('index', { path: '/' }); this.route('favorites'); }); Index 会渲染在 application 的 outlet ，当改变 URL 为 favorites 后，application 的 outlet 又会被 favorites 取代。 同理，一个嵌套路由： Router.map(function() { this.route('posts', function() { this.route('favorites'); }); }); 等价于： Router.map(function() { this.route('index', { path: '/' }); this.route('posts', function() { this.route('index', { path: '/' }); this.route('favorites'); }); }); 当用户访问 /posts 其实是访问的是 posts.index ，posts/index.hbs 会渲染在 posts 的 outlet 中，如果用户又去访问 posts/favorites ，outlet 的又会被替换成 posts/favorites.hbs，当前路由变成 posts.favorites。 Index route 的使用时机 Index route 一般用在嵌套路由中，比如博客 URL 的 /posts 表示的是博客的列表页，而 /posts/1234 表示一篇具体的博客，这个时候就可以用 index route 显示博客列表，类似： Router.map(function() { this.route('posts', function() { this.route('post', { path: '/:post_id' }); this.route('index', { path: '/' }); }) }); Dynamic segment Ember app 中的 URL 不仅仅反应的是要渲染不同的 template，也可能代表要渲染不同的 model，route 是根据 URL 中的 dynamic segment 来过滤 model 的。 Router.map(function() { this.route('posts'); this.route('post', { path: '/post/:post_id' }); }); 在上面的路由中，posts 代表的就是列表的 model，不需要用任何条件过滤，而 post 代表的是具体某个 model，需要 URL 中的 : 后面部分的 post_id 来标识，表示 URL 的 dynamic segment，比如访问 /posts/5 含义就是 post_id 部分是 5，Ember 会把 dynamic segment 作为一个 hash object 传给 route 的 model 函数。 import Route from '@ember/routing/route'; export default Route.extend({ model(params) { return this.get('store').findRecord('photo', params.photo_id); } }); 需要注意的是，在整个嵌套路由中 ，dynamic segment 的 key 必须是唯一的，意味着： // This won't work! The dynamic segments will collide. Router.map(function() { this.route('photo', { path: '/photo/:id' }, function() { this.route('comment', { path: '/comment/:id' }); }); }); 上面相同 key 是无法工作的。 wildcard route 通配符 route 是表示如果没有任何一个 route 能够匹配当前的 URL，则路由到 wildcard route 上： Router.map(function() { this.route('not-found', { path: '/*path' }); }); 需要注意的是如果想手动重定向到这样的 route 上，需要带上任意非空的参数： this.transitionTo('not-found', 404); route 之间的切换 在 Ember App 中如何对不同的 route 进行切换取决于 transition 发生的位置。 如果在 template 中，使用 {{link-to}} 如果在 route 中，使用 transitionTo() 如果在 controller 中，使用 transitionToRoute() 如果在 Component 中，注入 router service，使用 transitionTo() 如果是 replaceWith，那么 route 不会加入 history 中 © 三月沙 all right reserved，powered by GitbookUpdated at 2022-01-22 10:25:17 "},"book/route/model.html":{"url":"book/route/model.html","title":" model hook","keywords":"","body":"model ember 的 route 通过 model hook 来处理来自后端的数据，比如 router 定义了一个 route Router.map(function() { this.route('favorite-posts'); }); 在 route 的 handler 中使用 model 这个 hook 来提供数据进行渲染： //app/routes/favorite-posts.js import Route from '@ember/routing/route'; export default Route.extend({ model() { return this.store.query('post', { favorite: true }); } }); 默认情况下 route 通过在 model 中返回 promise 或者普通的 JavaScript 对象来提供数据，如果是 promise，route 会等待 promise 解析完成才去渲染 template。 Route 会把 model 返回的 value 挂在 controller 的 model 属性上，然后就可以在 template 中引用来自 controller 的 model 了： Favorite Posts {{#each model as |post|}} {{post.body}} {{/each}} 除了 model 这个 hook ，route 还提供了 beforeModel afterModel 这两个 hook 来完成在 model 解析前和解析后的工作。 beforeModel hook 发生在 model hook 调用之前的 hook: beforeModel(transition){ return Any | Promise } 可以在这个 hook 中调用 transition 的 abort 或者 retry 完成对 route 的特定处理，也可以使用 this.transitionTo 完成跳转。 如果这个hook 返回 promise，route 会等待 promise 解析完成，可以在这个 hook 完成一些异步操作。 afterModel hook 发生在 model hook 调用之后的 hook: afterModel(model, transition){ return Any | Promise } 可以在这个 hook 中根据 model 的内容执行对应的逻辑判断，然后再做跳转处理，如果这个 hook 返回 promise route 会等待直到 promise 解析完成。 dynamic model 除了通过 model hook 返回固定的 model，route 还支持通过 URL 来区分不同的 model，称之为 dynamic model，用以区分不同的 model 的 URL 中的参数称之为 dynamic segment。比如有一个列表是 /photos 显示图片列表，当用户点击单个图片的时候比如说 /photos/1 会使用不同的 model 渲染不同的 template。 更多参见 Route model hook 调用的时机 一个带 dynamic segment 的 url 如果总是通过浏览器的 url 进入，那么 route 的 model hook 总是会被调用。 如果一个 route 是通过 transition 进入，比如 link-to 组件，而且还提供了 model 上下文，比如 link-to 的第二个参数是一个 object，这表示 model 需要数据其实已经存在了，这是 hook 都不会被调用。如果第二个参数是一个标识符，比如 id 或其他，那么 model hook 会被调用。 Photos {{#each model as |photo|}} {{#link-to \"photo\" photo}} {{/link-to}} {{/each}} 上面传给 link-to 的是 model，hook 不会被调用。 Photos {{#each model as |photo|}} {{#link-to \"photo\" photo.id}} {{/link-to}} {{/each}} 上面传给 link-to 的是 id，hook 会被调用。 不带 dynamic segment 的 route 不论传递什么参数总是会被调用 多个 model Model hook 支持返回多个 model ，这是通过 RSVP.hash 完成的，hash 把多个 promise 的 value 重新组织成一个 promise 并返回，新的 promise 的 value 就是多个 promise 的 value 组成的 object： //app/routes/songs.js import Route from '@ember/routing/route'; import RSVP from 'rsvp'; export default Route.extend({ model() { return RSVP.hash({ songs: this.store.findAll('song'), albums: this.store.findAll('album') }); } }); 在 template 中渲染： Playlist {{#each model.songs as |song|}} {{song.name}} by {{song.artist}} {{/each}} Albums {{#each model.albums as |album|}} {{album.title}} by {{album.artist}} {{/each}} 重用 route 的上下文，获取 parent route 的信息 有些场景之下，需要从当前 route 中获取 parent route 的一些信息，在 Ember 中是通过 paramsFor 完成的： //app/routes/album/index.js import Route from '@ember/routing/route'; export default Route.extend({ model() { let { album_id } = this.paramsFor('album'); return this.store.query('song', { album: album_id }); } }); 除了获取 parent route 的相关信息，paramsFor 还可以用来在当前 route 的 action 或 method 中获取当前 route 的参数，用法如下： this.paramsFor(this.routeName) 在很多场合，可能 parent route 的 model 更有用，用 modelFor 可以完成这个工作: //app/routes/album/index.js import Route from '@ember/routing/route'; export default Route.extend({ model() { let { songs } = this.modelFor('album'); return songs; } }); © 三月沙 all right reserved，powered by GitbookUpdated at 2022-01-22 10:25:17 "},"book/route/query-params.html":{"url":"book/route/query-params.html","title":"query parameter","keywords":"","body":"URL 的 query parameter 默认情况 url 中的 query parameter 会一直带在 url 的后面，可以显示指定让其消失，按照下面的方法 link-to 中指定 query-params 为 null 对应路由的 controller 中要指定 为 null {{#link-to \"index\" (query-params classes=null channel=null material=null tag=null) class=\"item\" }}我的书架{{/link-to}} import Ember from 'ember'; export default Ember.Controller.extend({ queryParams: ['material','channel','classes','tag'], material: null, channel: null, classes: null, tag: null }); © 三月沙 all right reserved，powered by GitbookUpdated at 2022-01-22 10:25:17 "},"book/route/route-loading-error.html":{"url":"book/route/route-loading-error.html","title":"loading 和 error","keywords":"","body":"Route 的 loading 和 error ember 通过模式匹配进行错误和 loading 处理，在 route 中的 beforeModel, model 和 afterModel hooks 提供进行 promise 解析前、中、后的处理。 loading 是如何工作的 简单的定义一个 template 名称是 loading，与 route A 和 B 同级，当 route 从 A --> B 跳转，ember 会在真正进入 B route 之前，也就是 B 的 model hooks 的 promise 未解析完成之前，进入一个 loading route，显示 loading 的状态，不过不同于其他 route ，loading route 并不会改变当前的 url，B 的 promise 解析完成之后，才会真正改变当前 url，退出 loading route 进入 B。 ember 寻找 loading route 对应的模板规则是，优先是同级目录下的 routeName-loading 或者 loading，然后根据以下顺序不断冒泡： foo.bar.slow-model-loading foo.bar.loading or foo.bar-loading foo.loading or foo-loading loading or application-loading 当进入 slow-model 时，ember 并不会使用 slow-model.loading ，slow-model.loading 会对 slow-model 层次之下的 route 起作用。 loading event loading 发生时会触发 loading event，如果当前 route 没有提供处理机制，事件会冒泡到 application，借助这个事件可以获取 transition 的 promise 状态来添加对应的逻辑： import Ember from 'ember'; export default Ember.Route.extend({ ... actions: { loading(transition, originRoute) { let controller = this.controllerFor('foo'); controller.set('currentlyLoading', true); transition.promise.finally(function() { controller.set('currentlyLoading', false); }); } } }); 注意：如果使用了在当前route中使用了 loading event，ember 就不会在去寻找对应的 loading hbs 了。 error 是如何工作的 Error 的原理和 loading 相似，只要 route 在 model,beforeModel,afterModel 发生 thrown error 或者 rejected promise returned，ember 会按照下面的顺序寻找 template 或者 route，优先同目录的同名 error，然后不断冒泡： foo.bar.error-model-error foo.bar.error or foo.bar-error error or application-error 当 error 发生是，route 中的 beforeModel，model，afterModel hooks 并不会被调用，只有 setupController 被调用: setupController: function(controller, error) { Ember.Logger.debug(error.message); this._super(...arguments); } If no viable error substates can be found, an error message will be logged. 如果没有可见的 error substates ，错误会被记录。 error event 同理 loading event，当有错误或者异常出现 error event 会被触发，如果当前 route 不提供 handler 来处理，这个事件会不断冒泡 import Ember from 'ember'; export default Ember.Route.extend({ model(params) { return this.get('store').findAll('privileged-model'); }, actions: { error(error, transition) { if (error.status === '403') { this.replaceWith('login'); } else { // Let the route above this handle the error. return true; } } } }); © 三月沙 all right reserved，powered by GitbookUpdated at 2022-01-22 10:25:17 "},"book/route/404.html":{"url":"book/route/404.html","title":"404 的实现","keywords":"","body":"ember 中的 404 页面 this.route('page-not-found', {path: '/*wildcard'}); ember router 中定义 path 为 /*wildcard 来处理未经定义的 route 来定义 404 页面 © 三月沙 all right reserved，powered by GitbookUpdated at 2022-01-22 10:25:17 "},"book/route/redirect.html":{"url":"book/route/redirect.html","title":"重定向","keywords":"","body":"重定向 为了控制用户访问 web page 的权限，Ember 提供了丰富多样的重定向机制，在 route 中调用 transitionTo，在 controller 中调用 transitionToRoute()，另一个具有相同功能的是 replaceWith() ，他们的不同之处在于 replaceWith 是替换当前 URL history。 如果重定向的 route 包含 dynamic segment，可以传递对应的 model 或者 id，如果传递 model ，route 的 model hook 将不会被调用。 在 model 解析之前重定向 beforeModel() 在 model hook 之前调用，所以方便在 model 解析之前进行重定向，beforeModel 接受当前 transition 作为第一个参数，因而可以实现完成权限认证之后重新跳回来的逻辑。 Router.map(function() { this.route('posts'); }); //app/routes/index.js import Route from '@ember/routing/route'; export default Route.extend({ beforeModel(/* transition */) { this.transitionTo('posts'); // Implicitly aborts the on-going transition. } }); 在 model 解析之后重定向 afterModel() 在 model hook 之后调用，因而接受 model 和 transition 两个参数，可以根据当前 model 的结果进行重定向。 Router.map(function() { this.route('posts'); this.route('post', { path: '/post/:post_id' }); }); //app/routes/posts.js import Route from '@ember/routing/route'; export default Route.extend({ afterModel(model, transition) { if (model.get('length') === 1) { this.transitionTo('post', model.get('firstObject')); } } }); 重定向到子 route 如果多个 route 是嵌套的，在 parent route 中调用 transitionTo 会导致在重定向到子 route 时，parent 的 model、beforeModel、afterModel 都会触发，为了防止这样的事情发生，Ember 提供了 redirect() 方法： //app/router.js Router.map(function() { this.route('posts', function() { this.route('post', { path: '/:post_id' }); }); }); //app/routes/posts.js import Route from '@ember/routing/route'; export default Route.extend({ redirect(model, transition) { if (model.get('length') === 1) { this.transitionTo('posts.post', model.get('firstObject')); } } }); © 三月沙 all right reserved，powered by GitbookUpdated at 2022-01-22 10:25:17 "},"book/route/template.html":{"url":"book/route/template.html","title":"模板渲染","keywords":"","body":"Template 的渲染 Route 的一大作用就是进行 template 渲染，默认情况下渲染的 template 和 route 是同名的： Router.map(function() { this.route('posts', function() { this.route('new'); }); }); posts 会渲染 posts.hbs ，posts.new 会渲染 posts/new.hbs。 每个 template 都会渲染在 parent route template 的 outlet 中，比如 posts.hbs 会渲染在 application.hbs 中的 outlet，posts/new.hbs 会渲染在 posts.hbs 的 outlet 中。 如果想修改默认渲染的 template 名称可以使用，templateName 属性： import Route from '@ember/routing/route'; export default Route.extend({ templateName: 'posts/favorite-posts' }); Route 还提供了 renderTemplate() hook 来对 template 的渲染进行更多的控制，比如指定特定的 outlet 和 controller。 © 三月沙 all right reserved，powered by GitbookUpdated at 2022-01-22 10:25:17 "},"book/template/":{"url":"book/template/","title":"模板","keywords":"","body":"ember template ember 中的 template engine 是 handlebars，提供有属性、逻辑、分支等不同模板属性，而且还提供了 helper 一种具有 JavaScript 逻辑的函数表达式，可以用来实现自定义模板属性。 每个 template 文件 hbs 都具有一个上下文 context 用来获取属性的值，通过 route 渲染的 hbs 的上下文 context 是 controller，而 component 中的 hbs 对应的上下文就是 component 的 JavaScript 文件，如果 component 用了 block form 形势，其 context 还包括使用 component 的父容器，有时候是一个 controller，有时候是一个 parent component。 属性表达式 在 hbs 中获取 context 中的属性值非常简单，使用 {{}} 表达式，无论这个属性值是用于普通的 html 文本或是 html 属性都是可以的。 #app/templates/application.hbs Hello, {{firstName}} {{lastName}}! firstName 和 lastName 属性来自于 application controller 这个 context，只要 context 中有对应的表达式就会显示对应的值，否则显示为空 Adding Data Attributes 默认情况下 component 的 html 属性不包含 data-* attribute，可以使用 component 的 attributeBindings 来完成 Ember.TextField.reopen({ attributeBindings: ['data-toggle', 'data-placement'] }); 条件表达式 if else 在 hbs 中可以很方便完成 if else 等简单的条件元素，为此 ember handlebars 提供了 if 和 unless 等 helper。 {{#if person}} Welcome back, {{person.firstName}} {{person.lastName}}! {{/if}} {{#if person}} Welcome back, {{person.firstName}} {{person.lastName}}! {{else}} Welcome back, some one {{/if}} {{#if person}} Welcome back, {{person.firstName}} {{person.lastName}}! {{else if child}} Welcome back, child {{else}} Welcome back, some one {{/if}} {{/if}} {{#unless person}} Welcome back, {{person.firstName}} {{person.lastName}}! {{/unless}} if 表达式为真时显示内容，为真的值包括所有非 null 和 undefined 以及 false 和 空字符串、0 以外的值，unless 则正好相反。 内联调用条件表达式 使用内敛的方式调用条件表达式可以很简洁的表达 if else 逻辑， {{if isFast \"zoooom\" \"putt-putt-putt\"}} ifFast 为真，显示 zoooom 否则显示 putt-putt-putt，内敛方式在判断 html class 属性会非常有用。 嵌套调用条件表达式 一个条件表达式的返回值可以作为另一个条件表达式的输入值，借此特性可以实现表达式的嵌套调用 {{if isFast (if isFueled \"zoooom\")}} each 表达式 迭代一个 list 使用 each 表达式。 {{#each people as |person|}} Hello, {{person.name}}! {{/each}} each 表达式的索引 在循环表达式中，第二个 block param 是迭代对象的索引值，多个 block param 之间用空格隔开 {{#each people as |person index|}} Hello, {{person.name}}! You're number {{index}} in line {{/each}} each 遇上空的 list 如果迭代对象为空，可以用 else 输出为空的条件下的值 {{#each people as |person|}} Hello, {{person.name}}! {{else}} Sorry, nobody is here. {{/each}} 加速 each 的渲染 可以指定迭代对象的 key 值来加速 each 的渲染，当 list 中的内容发生变化，可以使用 key 来指定 ember 需要监听的属性值的变化以达到重新渲染的目的。 {{#each model key=\"id\" as |item|}} {{/each}} each-in 表达式 {{each-in}} 表达式能够迭代一个 object 的属性和值 {{#each-in user as |key value|}} {{key}}: {{value}} {{/each-in}} each-in 一样可以使用 else 表达对象为空的条件 {{#each-in user as |key value|}} {{key}}: {{value}} {{else}} no value {{/each-in}} © 三月沙 all right reserved，powered by GitbookUpdated at 2022-01-22 10:25:17 "},"book/template/link-to.html":{"url":"book/template/link-to.html","title":"URL","keywords":"","body":"link-to component link-to component 用来创建 route 的链接 {{#link-to 'index' }}index{{/link-to}} index 为 route 名称，生成的 html 是 index，如果当前的 url 正好是此 route，class 中会有名称为 active 的 class index。 route 的 url 参数 如果 route 包含 url 参数，在 link-to route 中可以指定 route 的参数 Router.map(function() { this.route('photos', function(){ this.route('edit', { path: '/:photo_id' }); }); }); {{#each photos as |photo|}} {{#link-to \"photos.edit\" photo}}{{photo.title}}{{/link-to}} {{/each}} Happy Kittens Puppy Running Mountain Landscape 如果 link-to 参数部分提供的是一个 object，link-to 会获取 object 属性 id 的值，如果不是 object，可以手动指定参数或者动态获取 {{#link-to \"photos.edit\" 1}}{{photo.title}}{{/link-to}} {{#link-to \"photos.edit\" photo.id}}{{photo.title}}{{/link-to}} {{#link-to \"photos.edit\" (get photo 'id')}}{{photo.title}}{{/link-to}} route query 参数 query-params helper 用来指定 route 的 query 参数。 {{#link-to \"photos.edit\" 1 (query-params keyword='qq') }}{{photo.title}}{{/link-to}} Mountain Landscape 想要 query 参数出现在 url 后面需要在 route 中指定 queryParams import Ember from 'ember'; export default Ember.Route.extend({ queryParams: { keyword: '' } }); 指定替换 url history 默认当 route 发生变化时，当前 route 是压栈进入浏览器的 history，可以指定 route history 的行为， {{#link-to \"photo.comment\" 5 primaryComment replace=true}} Main Comment for the Next Photo {{/link-to}} replace=true 会替换当前的 history state © 三月沙 all right reserved，powered by GitbookUpdated at 2022-01-22 10:25:17 "},"book/template/input.html":{"url":"book/template/input.html","title":"表单","keywords":"","body":"form element helper ember 还提供了几个很重要的 form element helper input checkbox textarea 详见 input-helper © 三月沙 all right reserved，powered by GitbookUpdated at 2022-01-22 10:25:17 "},"book/template/helper-index.html":{"url":"book/template/helper-index.html","title":"内建 helper 一览表","keywords":"","body":"内建 helper 一览表 ember 内建的 helper 能够帮助开发者完成很多重要的工作，以下是常见的 helper get if unless concat mut action query-params each-in partial input textarea component link-to ... 详见 helpers © 三月沙 all right reserved，powered by GitbookUpdated at 2022-01-22 10:25:17 "},"book/template/dev-helper.html":{"url":"book/template/dev-helper.html","title":"开发 helper","keywords":"","body":"开发自定义 helper 使用 ember g helper my-format-helper 生成 helper。 helper 接受两种形式的参数，一种是类似数组，一种类似 hash，使用 helper 时，如果参数不指定名字表示的就是数组行，如果指定了名字就可以使用 hash 的方式存取 {{my-format-helper 'beijing' name='beijing'}} helper 中最重要的是调用 ember 提供的几个工具函数，见 `` © 三月沙 all right reserved，powered by GitbookUpdated at 2022-01-22 10:25:17 "},"book/controller/controller.html":{"url":"book/controller/controller.html","title":"控制器","keywords":"","body":"© 三月沙 all right reserved，powered by GitbookUpdated at 2022-01-22 10:25:17 "},"book/cli/":{"url":"book/cli/","title":"Ember-cli","keywords":"","body":"ember-cli ember-cli 提供创建 ember app 的全套开发环境，一键初始化工程、测试、打包、发布。ember-cli 的详细使用案例官方基本都有介绍 https://ember-cli.com/，在次只介绍一些特殊场景下需要的注意事项。 安装 ember-cli npm install -g ember-cli ember-cli 的版本是随着 ember 的版本变更而变更的，版本号几乎一样 初始化一个项目 ember new ember-app 使用 app-import copy、concat 第三方依赖 文档 https://ember-cli.com/user-guide/#using-appimport 描述了如何使用 app.import copy、concat 第三方依赖。在 ember-cli 中，ember app 工程的第三方配置使用是在 ember-cli-build.js 中配置完成。如果 ember-app 是一个 ember-addon 工程，第三方依赖在 index.js 中配置使用 引入第三方 Non-AMD 依赖 app.import('bower_components/moment/moment.js'); 声明为全局变量使用 import Ember from 'ember'; /* global moment */ // No import for moment, it's a global called `moment` // ... var day = moment('Dec 25, 1995'); ember app 几个目录结构说明 vendor 第三方 JavaScript public 图片等文件，如果需 app/styles css or less 等文件 Asset compilation public/assets 放置需要的 font 、image 等文件，比如在 public/assets/images 目录下就可以在 css 中 url('/assets/images/logo.png') 这么引用 文件目录生成映射 Assets Output File app/index.html index.html app/**/*.js /assets/application-name.js app/styles/app.css /assets/application-name.css app/styles/**/*.css /assets/application-name.css JavaScript files you import with app.import /assets/vendor.js CSS files you import with app.import /assets/vendor.css © 三月沙 all right reserved，powered by GitbookUpdated at 2022-01-22 10:25:17 "},"book/action.html":{"url":"book/action.html","title":"event 和 action","keywords":"","body":"ember action ember 中的 action 顾名思义代表的是事件的处理，在 controller、route、application 以及 component 都有一个 actions hash 用来定义相应的 action，在 template 中使用 action 使用 handlebar 提供的 action helper。 action 根据自身 context 的不同会在不同 上下文的 actions 查找。route 对应的 template 中的 action 会优先在 controller 中查找，如果没有找到会向 route 冒泡，直到 application。component 中的 action 在 component 中查找，并且可以向父容器冒泡。 actions: { deleteUser(){ //todo } } delete user 指定事件类型 action 默认处理的是 click 事件，但是可以指定事件的类型，注意事件名称是必须是 camelCased 的风格。 delete user action 传递多个参数 delete user Ember.route({ actions: { deleteUser(param1, param2){ console.log(param1); console.log(param2); } } }) modifier key 辅助键的处理 ember action 默认会忽略来自 modifier key 的事件，如果希望启用来自 modifier key 的事件可以使用 allowedKeys click me 当按下 alt 键，action 事件将触发 阻止默认事件 ember 默认会阻止 dom 在浏览器的默认行为，使用 preventDefault=false 取消阻止 Go preventDefault=false 存在，点击锚点，ember action 被触发，同时浏览器发生跳转，如果去掉 preventDefault=false，点击锚点仅仅会触发 ember 事件 action 的第一个参数 If a value option for the helper is specified, its value will be considered a property path that will be read off of the first parameter of the action. This comes very handy with event listeners and enables to work with one-way bindings. 如果在 action helper 中指定一个 value，这个 value 将会当成 action 的第一个参数传入，使用内敛的方式调用 What's your favorite band? By default, the action handler receives the first parameter of the event listener, the event object the browser passes to the handler, so bandDidChange prints Event {}. 默认情况下，内敛 action 第一个参数是 event 如果不指定 value 值。 获取原始的浏览器 event 如果想要在 action 中获取原始的浏览器事件，在普通的模板中可以使用内敛事件的方式使用 action Sign Up actions: { signUp: function(event){ // Only when assigning the action to an inline handler, the event object // is passed to the action as the first parameter. } } 在 component 中，使用事件名称定义方法来获得原始的 event 对象 import Ember from 'ember'; export default Ember.Component.extend({ doubleClick(e) { alert(\"DoubleClickableComponent was clicked!\"); } }); component 的第一个参数就是原始的 event 对象 默认的 action 行为 The normal behavior for a function defined in actions does not receive the browser event as an argument. action 的默认行为并不会传入浏览器的 event 事件类型，其调用行为就是一个简单的 函数调用 Sign Up actions: { signUp: function(){ // No event object is passed to the action. } } event name list Touch events touchStart touchMove touchEnd touchCancel Keyboard events keyDown keyUp keyPress Mouse events mouseDown mouseUp contextMenu click doubleClick mouseMove focusIn focusOut mouseEnter mouseLeave Form events submit change focusIn focusOut input HTML5 drag and drop events dragStart drag dragEnter dragLeave dragOver dragEnd drop © 三月沙 all right reserved，powered by GitbookUpdated at 2022-01-22 10:25:17 "},"book/QA.html":{"url":"book/QA.html","title":"QA","keywords":"","body":"Questions ember route call renderTemplate into some template ember 在 route 中使用 renderTemplate 调用非 application 模板会报 bug not found https://github.com/emberjs/ember.js/issues/10780 ember 官方不建议再使用 renderTemplate 而使用 https://github.com/ef4/ember-elsewhere //raise error not found renderTemplate(){ this.render('project/group', { into: 'project/detail', }) } //work well renderTemplate(){ this.render('project/detail', { into: 'application', }) } 子 route 中获取 parent params import Ember from 'ember'; import {find_project_by_name} from '../data/main'; export default Ember.Route.extend({ model(param, transition){ return find_project_by_name(transition.params[\"project.org\"]}, param.project_name); } }); route 中请求多个 API import Route from '@ember/routing/route'; import { hash } from 'rsvp'; export default Route.extend({ model(params){ return hash({ app: this.store.findOne('app', params.id), computer: this.store.find('computer', {appid: params.id}) }); } }); route 支持多个 dynamic segment Ember.Route.extend({ serialize: function(model) { return { listing_id : model.get(\"listing_id\"), video_id : model.get(\"id\") }; } }) params 支持改写 子 controller 获取父 controller model 通过 inject controller 来获取 model，但是这个 controller 必须要显式存在，也就是 controller 文件必须要存在，否则由于 ember 会默认在 runtime 生成没有声明的 controller 对象，在当前业务如果是通过url进入，不知道什么原因，ember 并未生成 controller 对象 import Controller, { inject } from '@ember/controller'; import {set, get} from '@ember/object'; import {godForm} from 'ember-easy-orm/mixins/form'; export default Controller.extend(godForm, { modelName: \"deploy\", parentController: inject('app.detail'), actions: { add(rd){ let app = get(this, 'parentController').model.app; set(this, 'selectedItem', this.store.createRecord('deploy', {commit_id: rd.short_id, app_id: app.id, status: \"new\"})); this.set('modalShow', true); } } }); 已经渲染并且使用过的组件如何恢复到初始状态 这个问题经常在选择组件中，比如 CheckBox group，CheckBox 已经在一次弹窗中使用过了，再次弹窗的时候需要把这组组件恢复到都未选中的状态，这个场景下最好把整个组件再次封装称为新的组件，动态的在渲染一次组件 返回到前一次 route 可以再 Router 中覆写 didTransition 函数，每次 route 进入之后会调用此函数，然后拿到 currentURL 存于 localStoreage ，只存最近访问的两次 didTransition: function() { this._super(...arguments); let routeName = this.currentURL; if (!localStorage['routeList']){ localStorage['routeList'] = routeName; this.set('previousRouteName', routeName); }else { localStorage['routeList'] = routeName + \",\" +localStorage['routeList']; let routeList = localStorage['routeList'].split(\",\"); routeList = routeList.splice(0, 2); this.set('previousRouteName', routeList[0]); localStorage['routeList'] = routeList.join(\",\") } } 父组件和子组件的通信 ember 父子组件通信是个比较麻烦的事情。首先如果子组件直接在父组件中，而不是通过 yield 的形式嵌入进去的，可以让父子组件都监听相同的值来完成通信 全局依赖管理 Ember app 中大部分的依赖通过 npm 来管理，有少部分包还需要用 bower 来引入，但是绝大部分可以不需要了，通过 npm 引入依赖： npm install package --save 如果报是全局的，还可以通过 shims 的形式替代用 import 导入，首先生成 shim ember generate vendor-shim moment 如果这是在 Ember Addon 中，然后在 index 中： app.import('vendor/shims/moment.js'); 如果是在 Eember app 中，在 ember-cli-build 中管理 启用 jquery ember install @ember/jquery ember install @ember/optional-features ember feature:enable jquery-integration © 三月沙 all right reserved，powered by GitbookUpdated at 2022-01-22 10:25:17 "}}